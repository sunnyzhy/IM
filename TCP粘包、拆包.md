# TCP 粘包、拆包

UDP是基于报文发送的，从UDP的帧结构可以看出，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。

而TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。

## 粘包、拆包的表现形式

现在假设客户端向服务端连续发送了两个数据包，用packet1和packet2来表示，那么服务端收到的数据可以分为以下三种：

第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。

![packet-1](./image/packet-1.png 'packet-1')

第二种情况，接收端收到了两个数据包，但是不知道这两个数据包的界限，这种现象即为粘包。

![packet-2](./image/packet-2.png 'packet-2')

第三种情况，接收端收到了两个数据包，但是其中一个数据包被拆成两部分并且数据包之间没有界限，这种情况即发生了拆包和粘包。

![packet-3](./image/packet-3.png 'packet-3')

![packet-4](./image/packet-4.png 'packet-4')

## 粘包、拆包发生的原因

发生TCP粘包或拆包主要有以下原因：

1. 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包

2. 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包

3. 要发送的数据大于TCP发送的缓冲区小，将会发生拆包

4. 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包

## 粘包、拆包的解决办法

解决办法的关键在于给每个数据包添加边界信息：

1. 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。通常使用自定义数据包的方法
   ![packet-5](./image/packet-5.png 'packet-5')
   比如：前4个字节表示数据包的长度，5-8个字节表示传输的类型，后面为实际的数据内容

2. 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来

3. 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开

## 参考

```https://blog.csdn.net/xpj8888/article/details/83856110```
